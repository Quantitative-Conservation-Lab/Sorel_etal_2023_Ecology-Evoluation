---
title: "multi-year independant ar1 wenatchee migrants"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Load Packages
```{r}
pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}#end of function

pkgTest("here")
```


###Load data
```{r}

source(here("src","Load Screw Trap Data.R"))

screw_trap_dat<-load_dat()

```

###function to make data and inits for model
```{r}

mod_ins<-function(p_mod_Mat, rel, rec, start_day, end_day, Catch, catch_dat, p_pred_mat){

#Efficiency Data
  
  #p_mod_Mat = design matrix for trap efficiency model
  
  #number of efficiency trials
  Ntrials<-nrow(p_mod_Mat)

  #rel = number released in efficiency trials
  
  #rec = number recaptured in efficiency trials

  #number of days to estimate migrants
  max_day<-length(start_day:end_day)
  
  
#Catch Data
  
  # number of years of data
  Nyears<-length(unique(catch_dat$year))
  
  #Vector of year index of catch data
  seriesFac<-as.numeric(catch_dat$year)-min(as.numeric(catch_dat$year))+1
  
  #Catch = Vector of Catch of subyearlings (fry and parr combined)

  # day of year of catches
  catch_DOY<-as.numeric(catch_dat$DOY)-start_day+1
  
  #Total length of catch vector
  N_trap<-length(Catch)
  
  #p_pred_mat = model matrix for predicting daily capture efficiency

  mod_data <- list(Ntrials=Ntrials,rec=rec,rel=rel,pDesign=p_mod_Mat,pDat=p_pred_mat,Catch=Catch,catch_DOY=catch_DOY,seriesFac=seriesFac,N_trap=N_trap, max_day=max_day,Nyears=Nyears)
     
     
#initial values
   #coefficients for capture efficiency model
   pCoefs <-rnorm(ncol(p_mod_Mat))                                         
   # intercepts of AR(1) process for log-mean daily outmigrants
   mu_M<-runif(Nyears,2,7)                                                 
   # AR(1) process error SD for log-mean daily outmigrants
   log_sigma_M<-runif(Nyears,-1,1)
  
   # AR(1) coefficient for log-mean daily outmigrants
   phi_M<-runif(Nyears,.1,.99)     
   
   #latent state z-scored log(expected migrants)
   log_M_hat_z<-matrix(rnorm(Nyears*max_day),nrow=Nyears,ncol=max_day)   
   
   #paramater list
   mod_pars=list(pCoefs=pCoefs,mu_M=mu_M, phi_M=phi_M, log_sigma_M=log_sigma_M,log_M_hat_z=log_M_hat_z)


#bounds
  lower=c(rep(-Inf,times=length(pCoefs)), rep(-Inf,Nyears),
        rep(-1,Nyears),rep(-Inf,Nyears),
         rep(-Inf,times=max_day*Nyears))



  upper=c(rep(Inf,times=length(pCoefs)), rep(Inf,Nyears),
        rep(1,Nyears),rep(Inf,Nyears),
         rep(Inf,times=max_day*Nyears))

#return
       list(mod_data=mod_data,mod_pars=mod_pars,lower=lower,upper=upper)
}


```

###load model
```{r}
require(TMB)

#TMB model
setwd(here("src","TMB"))
compile("multi_year_independant_1.cpp")
dyn.load(dynlib("multi_year_independant_1"))
```


###Chiwawa subyearlings
```{r}

#add scaled discharge column
screw_trap_dat$chiw$chiw_effic$log.dis.scale<-scale(log(screw_trap_dat$chiw$chiw_effic$disch.cfs))
#store mean
mean.chiw.disch<-attributes(screw_trap_dat$chiw$chiw_effic$log.dis.scale)$`scaled:center`
#store standard deviation
sd.chiw.disch<-attributes(screw_trap_dat$chiw$chiw_effic$log.dis.scale)$`scaled:scale`
#make design matrix
p_mod_Mat<-model.matrix(~lifeStage+log.dis.scale*position2-1,screw_trap_dat$chiw$chiw_effic)


#design matrix for observation model

#make a copy of the catch data with no NA catches
subs_no_NA<-droplevels(subset(screw_trap_dat$chiw$chiw_catch,!is.na(screw_trap_dat$chiw$chiw_catch$allSubs)))


#*********   Guess at missing trap positions   **********
#*********   should be estimated in model in future   ***
tapply(screw_trap_dat$chiw$chiw_effic$disch.cfs,screw_trap_dat$chiw$chiw_effic$position2,summary)

subs_no_NA$Position2[subs_no_NA$Position2==""& subs_no_NA$Position2<=475]<-"Upper"

subs_no_NA$Position2[subs_no_NA$Position2==""]<-"Lower"


#scale discharge
subs_no_NA$log_scale_Dis<-(log(subs_no_NA$dis)-mean.chiw.disch)/sd.chiw.disch

#add a column of the lifestage that we are estimating
subs_no_NA$lifeStage<-factor("SBC",levels = c("SBC","YCW","YCW & SBC"))

p_pred_mat<-model.matrix(~lifeStage+log_scale_Dis*Position2-1,subs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$chiw$chiw_effic$rel,
                 rec=screw_trap_dat$chiw$chiw_effic$recap,
                 start_day=as.numeric(min(subs_no_NA$DOY)),
                 end_day=as.numeric(max(subs_no_NA$DOY)),
                 Catch=subs_no_NA$allSubs,
                 catch_dat=subs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_ch_subs <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_ch_subs_fit<- nlminb(model_ch_subs$par, model_ch_subs$fn, model_ch_subs$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   



  rep_ch_subs<-model_ch_subs$report()
  rep$mu_M
  log_m_hat_ch_subs<-rep_ch_subs$log_M_hat
  
  cor(rep$mu_M,
  rep2$mu_M)
  
  
rowSums(exp(log_m_hat))
rowSums(exp(log_m_hat2))
rowSums(exp(log_m_hat3))
rowSums(exp(log_m_hat4))


  plot(colMeans(exp(log_m_hat_ch_subs)),type="l",ylab="",xlab="",xaxt="n")
seDa<-seq.Date(from=as.Date("2019-01-01"),to=as.Date("2019-12-31"),by=1)


km<-kmeans(rep(1:length(colMeans(exp(log_m_hat_ch_subs))),times=round(colMeans(exp(log_m_hat)))),3)

km$centers
table(km$cluster)

days<-c(91,182,274,366,(365+91))-50
labs<-c("Apr","Jul","Oct","Jan","Apr")
axis(1,at=days,labels=labs)


# abline(v=87,col="red")
# abline(v=215,col="red")
# abline(v=345,col="red")


```

###Chiwawa Yearlings
```{r}


#make a copy of the catch data with no NA catches
yrlngs_no_NA<-droplevels(subset(screw_trap_dat$chiw$chiw_catch,!is.na(screw_trap_dat$chiw$chiw_catch$yrlngCatch)&screw_trap_dat$chiw$chiw_catch$DOY<=212 ))


#scale discharge
yrlngs_no_NA$log_scale_Dis<-(log(yrlngs_no_NA$dis)-mean.chiw.disch)/sd.chiw.disch

#add a column of the lifestage that we are estimating
yrlngs_no_NA$lifeStage<-factor("YCW",levels = c("SBC","YCW","YCW & SBC"))


#*********   Guess at missing trap positions   **********
#*********   should be estimated in model in future   ***
tapply(screw_trap_dat$chiw$chiw_effic$disch.cfs,screw_trap_dat$chiw$chiw_effic$position2,summary)

yrlngs_no_NA$Position2[yrlngs_no_NA$Position2==""& yrlngs_no_NA$Position2<=475]<-"Upper"

yrlngs_no_NA$Position2[yrlngs_no_NA$Position2==""]<-"Lower"


#scale discharge
yrlngs_no_NA$log_scale_Dis<-(log(yrlngs_no_NA$dis)-mean.chiw.disch)/sd.chiw.disch

#add a column of the lifestage that we are estimating
yrlngs_no_NA$lifeStage<-factor("YCW",levels = c("SBC","YCW","YCW & SBC"))

p_pred_mat<-model.matrix(~lifeStage+log_scale_Dis*Position2-1,yrlngs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$chiw$chiw_effic$rel,
                 rec=screw_trap_dat$chiw$chiw_effic$recap,
                 start_day=as.numeric(min(yrlngs_no_NA$DOY)),
                 end_day=as.numeric(max(yrlngs_no_NA$DOY)),
                 Catch=yrlngs_no_NA$yrlngCatch,
                 catch_dat=yrlngs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_Ch_yrlng <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_1_fit<- nlminb(model_Ch_yrlng$par, model_Ch_yrlng$fn, model_Ch_yrlng$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   



  rep_model_Ch_yrlng<-model_Ch_yrlng$report()
  log_m_hat_model_Ch_yrlng<-rep_model_Ch_yrlng$log_M_hat
  
rowSums(exp(log_m_hat_model_Ch_yrlng))

  plot(colMeans(exp(log_m_hat_model_Ch_yrlng)),type="l",ylab="",xlab="",xaxt="n")
seDa<-seq.Date(from=as.Date("2019-01-01"),to=as.Date("2019-12-31"),by=1)

days<-c(91,182,274,366,(365+91))-50
labs<-c("Apr","Jul","Oct","Jan","Apr")
axis(1,at=days,labels=labs)


# abline(v=87,col="red")
# abline(v=215,col="red")
# abline(v=345,col="red")


```




###Nason Subyearlings
```{r}

#add scaled discharge column
screw_trap_dat$nas$nas_effic$log.dis.scale<-scale(log(screw_trap_dat$nas$nas_effic$discharge2))
#store mean
mean.nas.disch<-attributes(screw_trap_dat$nas$nas_effic$log.dis.scale)$`scaled:center`
#store standard deviation
sd.nas.disch<-attributes(screw_trap_dat$nas$nas_effic$log.dis.scale)$`scaled:scale`
#make design matrix
p_mod_Mat<-model.matrix(~Lifestage2:log.dis.scale+moved-1,screw_trap_dat$nas$nas_effic)

summary(glm(p~Lifestage2:log.dis.scale+moved-1,family="binomial",data=screw_trap_dat$nas$nas_effic,weights=number.released))
#design matrix for observation model

#make a copy of the catch data with no NA catches
screw_trap_dat$nas$nas_catch$all_subs<-screw_trap_dat$nas$nas_catch$Sub_catch+screw_trap_dat$nas$nas_catch$Fry_catch
subs_no_NA<-droplevels(subset(screw_trap_dat$nas$nas_catch,!is.na(screw_trap_dat$nas$nas_catch$all_subs)))


#add "moved: factor to trap operations data
subs_no_NA$moved<-as.factor(ifelse(subs_no_NA$Date2<=as.Date("2014-06-30"),"0","1"))



#scale discharge
subs_no_NA$log_scale_Dis<-(log(subs_no_NA$Discharge2)-mean.nas.disch)/sd.nas.disch

#add a column of the lifestage that we are estimating
subs_no_NA$lifeStage<-factor("Subyearling",levels = unique(screw_trap_dat$nas$nas_effic$Lifestage2))

p_pred_mat<-model.matrix(~lifeStage:log_scale_Dis+moved-1,subs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$nas$nas_effic$number.released,
                 rec=screw_trap_dat$nas$nas_effic$number.recaptured,
                 start_day=as.numeric(min(subs_no_NA$DOY)),
                 end_day=as.numeric(max(subs_no_NA$DOY)),
                 Catch=subs_no_NA$all_subs,
                 catch_dat=subs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_nas_subs <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_nas_subs_fit<- nlminb(model_nas_subs$par, model_nas_subs$fn, model_nas_subs$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   


  model_nas_subs_SD<-sdreport(model_nas_subs)
  summary(model_nas_subs_SD)
model_nas_subs_rep<-model_nas_subs$report()
model_nas_subs_log_m_hat<-model_nas_subs_rep$log_M_hat
rowSums(exp(model_nas_subs_log_m_hat))
plot(colMeans(exp(model_nas_subs_log_m_hat)),type="l")

```


###Nason Yearlings
```{r}

#make a copy of the catch data with no NA catches
yrlngs_no_NA<-droplevels(subset(screw_trap_dat$nas$nas_catch,!is.na(screw_trap_dat$nas$nas_catch$Yrlng_catch)&screw_trap_dat$nas$nas_catch$DOY<=212))


#add "moved: factor to trap operations data
yrlngs_no_NA$moved<-as.factor(ifelse(yrlngs_no_NA$Date2<=as.Date("2014-06-30"),"0","1"))



#scale discharge
yrlngs_no_NA$log_scale_Dis<-(log(yrlngs_no_NA$Discharge2)-mean.nas.disch)/sd.nas.disch

#add a column of the lifestage that we are estimating
yrlngs_no_NA$lifeStage<-factor("Yearling",levels = unique(screw_trap_dat$nas$nas_effic$Lifestage2))

p_pred_mat<-model.matrix(~lifeStage:log_scale_Dis+moved-1,yrlngs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$nas$nas_effic$number.released,
                 rec=screw_trap_dat$nas$nas_effic$number.recaptured,
                 start_day=as.numeric(min(yrlngs_no_NA$DOY)),
                 end_day=as.numeric(max(yrlngs_no_NA$DOY)),
                 Catch=yrlngs_no_NA$Yrlng_catch,
                 catch_dat=yrlngs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_nas_yrlngs <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_nas_yrlngs_fit<- nlminb(model_nas_yrlngs$par, model_nas_yrlngs$fn, model_nas_yrlngs$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   


  model_nas_yrlngs_SD<-sdreport(model_nas_yrlngs)
  
model_nas_yrlngs_rep<-model_nas_yrlngs$report()
model_nas_yrlngs_log_m_hat<-model_nas_yrlngs_rep$log_M_hat
rowSums(exp(model_nas_yrlngs_log_m_hat))
plot(colMeans(exp(model_nas_yrlngs_log_m_hat)),type="l")

```


###White River subyearlings
```{r}

#add scaled discharge column
screw_trap_dat$whi$nhi_effic$log.dis.scale<-scale(log(screw_trap_dat$whi$nhi_effic$discharge2))
#store mean
mean.whi.disch<-attributes(screw_trap_dat$whi$nhi_effic$log.dis.scale)$`scaled:center`
#store standard deviation
sd.whi.disch<-attributes(screw_trap_dat$whi$nhi_effic$log.dis.scale)$`scaled:scale`
#make design matrix
p_mod_Mat<-model.matrix(~Lifestage2*log.dis.scale-1,screw_trap_dat$whi$nhi_effic)

summary(glm(p~Lifestage2*log.dis.scale-1,family="binomial",data=screw_trap_dat$whi$nhi_effic,weights=number.released))
#design matrix for observation model

#make a copy of the catch data with no NA catches
screw_trap_dat$whi$whi_catch$all_subs<-screw_trap_dat$whi$whi_catch$Sub_catch+screw_trap_dat$whi$whi_catch$Fry_catch
subs_no_NA<-droplevels(subset(screw_trap_dat$whi$whi_catch,!is.na(screw_trap_dat$whi$whi_catch$all_subs)))



#scale discharge
subs_no_NA$log_scale_Dis<-(log(subs_no_NA$Discharge2)-mean.whi.disch)/sd.whi.disch

#add a column of the lifestage that we are estimating
subs_no_NA$lifeStage<-factor("Subyearling",levels = unique(screw_trap_dat$whi$nhi_effic$Lifestage2))

p_pred_mat<-model.matrix(~lifeStage*log_scale_Dis-1,subs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$whi$nhi_effic$number.released,
                 rec=screw_trap_dat$whi$nhi_effic$number.recaptured,
                 start_day=as.numeric(min(subs_no_NA$DOY)),
                 end_day=as.numeric(max(subs_no_NA$DOY)),
                 Catch=subs_no_NA$all_subs,
                 catch_dat=subs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_whi_subs <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_whi_subs_fit<- nlminb(model_whi_subs$par, model_whi_subs$fn, model_whi_subs$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   


  #model_nas_subs_SD<-sdreport(model_nas_subs)
  #summary(model_nas_subs_SD)
model_whi_subs_rep<-model_whi_subs$report()
model_whi_subs_log_m_hat<-model_whi_subs_rep$log_M_hat
rowSums(exp(model_whi_subs_log_m_hat))
plot(colMeans(exp(model_whi_subs_log_m_hat)),type="l")
```

###White River Yearlings
```{r}

#make a copy of the catch data with no NA catches

yrlngs_no_NA<-droplevels(subset(screw_trap_dat$whi$whi_catch,!is.na(screw_trap_dat$whi$whi_catch$Yrlng_catch)&screw_trap_dat$whi$whi_catch$DOY<=212))



#scale discharge
yrlngs_no_NA$log_scale_Dis<-(log(yrlngs_no_NA$Discharge2)-mean.whi.disch)/sd.whi.disch

#add a column of the lifestage that we are estimating
yrlngs_no_NA$lifeStage<-factor("Yearling",levels = unique(screw_trap_dat$whi$nhi_effic$Lifestage2))

p_pred_mat<-model.matrix(~lifeStage*log_scale_Dis-1,yrlngs_no_NA)


mod_dat<-mod_ins(p_mod_Mat=p_mod_Mat,
                 rel=screw_trap_dat$whi$nhi_effic$number.released,
                 rec=screw_trap_dat$whi$nhi_effic$number.recaptured,
                 start_day=as.numeric(min(yrlngs_no_NA$DOY)),
                 end_day=as.numeric(max(yrlngs_no_NA$DOY)),
                 Catch=yrlngs_no_NA$Yrlng_catch,
                 catch_dat=yrlngs_no_NA,
                 p_pred_mat=p_pred_mat)

#Settup subyearling model
  model_whi_yrlng <- MakeADFun(mod_dat$mod_data, mod_dat$mod_pars,  
                         random=c("log_M_hat_z"),
                     DLL="multi_year_independant_1",silent=T)
  
  model_whi_yrlng_fit<- nlminb(model_whi_yrlng$par, model_whi_yrlng$fn, model_whi_yrlng$gr, 
                    control=list(rel.tol=1e-12,eval.max=1000000,
                                 iter.max=10000),
                    lower=mod_dat$lower, upper=mod_dat$upper)   


  #model_nas_subs_SD<-sdreport(model_nas_subs)
  #summary(model_nas_subs_SD)
model_whi_yrlng_rep<-model_whi_yrlng$report()
model_whi_yrlng_log_m_hat<-model_whi_yrlng_rep$log_M_hat
rowSums(exp(model_whi_yrlng_log_m_hat))
plot(colMeans(exp(model_whi_yrlng_log_m_hat)),type="l")

```




```{r}
source(here("src","Discharge data funcs.R"))


Chiw_discharge<-Chiw_discharge_func()

dev.new(width = 10, height = 10)
pdf(file="test.pdf")
par(mfrow = c(4,3), mar = c(3,4.5,2,0.5), oma = c(1,0,1,0))


  c1 <- transparent("blue", 0.3)
  for(i in 22:1){
      acf((rep$log_M_hat_z[i,]),main="")
    mtext(unique(subs_no_NA$year)[i],3,1,xpd=NA,outer=F,cex=1.5)
    qqnorm((rep$log_M_hat_z[i,]))
  qqline((rep$log_M_hat_z[i,]))
  
   plot((rep$log_M_hat_z[i,]), pch = 1,type="l",col="blue",xlab = "", ylab = "process error",)
    
  }
  dev.off()
        # xlim = c(55,525), ylim = c(0, log(2500)),
       #  xlab = "", ylab = "", las = 1, cex.lab = 1.2, cex.axis = 1,main=unique(subs_no_NA$year)[i])  }
    #, xaxt = "n")


```


## 


Link to documentation of AR1 function in TMB
<https://kaskr.github.io/adcomp/classdensity_1_1AR1__t.html>.


This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see 

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
